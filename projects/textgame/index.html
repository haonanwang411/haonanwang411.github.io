<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd"> <html><body> <h2 id="background">Background</h2> <p><a href="https://arxiv.org/abs/2305.14879" rel="external nofollow noopener" target="_blank">Byte-sized text games</a> are used for code-generation tasks in virtual environments. In this <a href="https://github.com/isle-dev/BYTESIZED32-Refactored/edit/main/README.md" rel="external nofollow noopener" target="_blank">refactored_BYTESIZED32</a>, we aim to optimize the code for a collection of 32 games with similar structures and mechanics. The key focus areas were modularity, readability, reusability, extensibility, and performance. Each game followed a common pattern with variations in game-specific rules, objects, and actions, which provided an excellent opportunity to abstract shared logic and create a reusable framework.</p> <h2 id="project-structure">Project structure</h2> <p>In our project structure, the old work(#) is the same as <a href="https://github.com/cognitiveailab/BYTESIZED32" rel="external nofollow noopener" target="_blank">Bytesized32</a>, and our new refactored games(*) work is also included.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>BYTESIZED32-main
├── data
│   ├── library
│   │   └── GameBasic.py          # Core framework for game object abstractions(*)
│   ├── playthroughs              # Command files for running pre-defined scenarios(#)
│   ├── programs                  # Original unrefactored game files(#)
│   └── refactored_programs       # Final refactored versions of the game files(*)
├── test_prompts                  # Prompt templates for testing game logic(#)
├── test_running                  # Scripts for automated game execution and these text games files are not the final games(Main function is different and only test code) (*)
├── results                       # Generated experimental results and evaluation files(#)
├── scripts                       # Utility scripts for experiment automation(#)
├── venv                          # Virtual environment for dependencies(#)
├── LICENSE                       # Project license(#)
├── README.md                     # Project documentation (this file)(#)
├── requirements.txt              # Python dependencies(#)
└── setup.py                      # Project setup script(#)
</code></pre></div></div> <h2 id="key-optimization-highlights">Key Optimization Highlights</h2> <h3 id="1-modular-design">1. Modular Design</h3> <p>Before Refactoring: Each game contained a large amount of duplicated code, including classes like <code class="language-plaintext highlighter-rouge">GameObject</code>, <code class="language-plaintext highlighter-rouge">Container</code>, and <code class="language-plaintext highlighter-rouge">TextGame</code>. Game-specific logic was intertwined with shared logic, making it difficult to isolate reusable components. After Refactoring: Shared Module (<code class="language-plaintext highlighter-rouge">GameBasic</code>): Abstracted common classes (<code class="language-plaintext highlighter-rouge">GameObject</code>, <code class="language-plaintext highlighter-rouge">Container</code>, <code class="language-plaintext highlighter-rouge">TextGame</code>, etc.) into a shared library, reducing redundancy. Game-Specific Classes: Individual games inherit from <code class="language-plaintext highlighter-rouge">TextGame</code>, focusing only on game-specific logic such as tasks, objects, and scoring. Benefits: Code reuse across all games. We simplified game-specific implementation. Centralized management of core functionalities, reducing maintenance effort.</p> <p>—</p> <h3 id="2-streamlined-action-handling">2. Streamlined Action Handling</h3> <p>Before Refactoring: Actions like <code class="language-plaintext highlighter-rouge">look around</code>, <code class="language-plaintext highlighter-rouge">take</code>, <code class="language-plaintext highlighter-rouge">put</code>, and game-specific commands were handled using repetitive <code class="language-plaintext highlighter-rouge">if-elif</code> blocks, leading to bloated code. After Refactoring: Introduced a <strong>dictionary-based <code class="language-plaintext highlighter-rouge">action_map</code></strong> to handle actions dynamically. Each action is mapped to a corresponding method or lambda function: <code class="language-plaintext highlighter-rouge">python action_map = { "look around": self.rootObject.makeDescriptionStr, "inventory": self.actionInventory, "take": lambda: self.actionTake(action[1]), "put": lambda: self.actionPut(action[1], action[2]), "answer": lambda: self.actionAnswer(action[1]) } </code> Benefits: Eliminated redundant <code class="language-plaintext highlighter-rouge">if-elif</code> statements. Easy to add or modify actions for individual games by updating the <code class="language-plaintext highlighter-rouge">action_map</code>. Improved readability and reduced code complexity.</p> <hr> <h3 id="3-recursive-logic-optimization">3. Recursive Logic Optimization</h3> <p>Before Refactoring: Recursive operations, such as retrieving all contained objects or calculating masses, used explicit loops with redundant code. After Refactoring: Used <strong>list comprehensions</strong> and <strong>combined recursive calls</strong>: <code class="language-plaintext highlighter-rouge">python def getAllContainedObjectsRecursive(self): return self.left.getAllContainedObjectsRecursive() + self.right.getAllContainedObjectsRecursive() + [self.left, self.right] </code></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>```python
def get_mass(self, contains):
    return sum(obj.getProperty("weight") for obj in contains.contains)
```
</code></pre></div></div> <p>Benefits: Cleaner, more concise implementations.Improved efficiency and maintainability.</p> <hr> <h3 id="4-enhanced-object-description">4. Enhanced Object Description</h3> <p>Before Refactoring: Descriptions for containers and their contents relied on verbose string concatenations and nested loops. After Refactoring: Simplified descriptions with list comprehensions: <code class="language-plaintext highlighter-rouge">python def makeOneSideDescription(contains): effectiveContents = [obj.makeDescriptionStr() for obj in contains.contains] if effectiveContents: return "contains " + ", ".join(effectiveContents[:-1]) + ( ", and " if len(effectiveContents) &gt; 1 else "") + effectiveContents[-1] return "is empty" </code></p> <p>Benefits: Reduced verbosity and improved readability. Consistent and elegant handling of object descriptions across games.</p> <hr> <h3 id="5-unified-game-logic">5. Unified Game Logic</h3> <p>Before Refactoring: Game-specific logic (e.g., tasks, scoring) was mixed into a single monolithic class, making it hard to isolate and extend. After Refactoring: Game Logic Isolation: Each game is implemented as a subclass of <code class="language-plaintext highlighter-rouge">TextGame</code>, with methods overridden for tasks, scoring, and object initialization. <code class="language-plaintext highlighter-rouge">python class BalanceScaleWeighGame(TextGame): def getTaskDescription(self): return "Your task is to figure out the weight of the cube." def calculateScore(self): self.score = 1 if self.cube_weight == self.answer_mass else 0 self.gameOver = True self.gameWon = self.score &gt; 0 </code></p> <p>Benefits: Clear separation of shared and game-specific responsibilities. Easier to implement new games with minimal duplication.</p> <h3 id="6-extended-features">6. Extended Features</h3> <p>Before Refactoring: Limited gameplay mechanics with predefined actions and rigid rules. After Refactoring: Added dynamic action generation based on game state: Actions like <code class="language-plaintext highlighter-rouge">answer</code> (specific to certain games) can be dynamically included. generatePossibleActions build action sets tailored to the game environment: <code class="language-plaintext highlighter-rouge">python for i in range(1, self.max_mass + 1): self.addAction(f"answer {i}g", ["answer", i]) </code></p> <ul> <li>Expanded scoring and feedback logic, allowing for more interactive and engaging gameplay.</li> </ul> <p>Benefits: Increased flexibility to define unique game rules and mechanics. Enhanced player experience with dynamic interactions.</p> <p>—</p> <h3 id="7-centralized-testing-and-execution">7. Centralized Testing and Execution</h3> <p>Before Refactoring: Each game had its own main loop, often with duplicate logic for handling input, generating actions, and updating states. After Refactoring: Unified the main game loop in the shared <code class="language-plaintext highlighter-rouge">TextGame</code> class. Games are instantiated and executed using the same <code class="language-plaintext highlighter-rouge">main(game)</code> function. Benefits: Standardized game execution. Simplified testing across multiple games.</p> <hr> <h3 id="overall-impact"><strong>Overall Impact</strong></h3> <table> <thead> <tr> <th><strong>Aspect</strong></th> <th><strong>Before Refactoring</strong></th> <th><strong>After Refactoring</strong></th> <th><strong>Improvement</strong></th> </tr> </thead> <tbody> <tr> <td><strong>Modularity</strong></td> <td>Monolithic scripts with duplicated logic</td> <td>Shared modules with reusable components</td> <td>Easier to manage, reuse, and extend functionalities.</td> </tr> <tr> <td><strong>Readability</strong></td> <td>Verbose and repetitive logic</td> <td>Streamlined with comprehensions and mappings</td> <td>Improved clarity and reduced cognitive load for developers.</td> </tr> <tr> <td><strong>Extensibility</strong></td> <td>Hard to add new features or games</td> <td>Game-specific logic isolated in subclasses</td> <td>New games or features require minimal effort to implement.</td> </tr> <tr> <td><strong>Performance</strong></td> <td>Explicit loops and redundant operations</td> <td>Optimized recursive calls and calculations</td> <td>Improved efficiency for recursive and state-dependent operations.</td> </tr> <tr> <td><strong>Action Handling</strong></td> <td>Repetitive <code class="language-plaintext highlighter-rouge">if-elif</code> structures</td> <td>Dynamic action mapping</td> <td>Reduced boilerplate and easier action management.</td> </tr> <tr> <td><strong>Testing and Execution</strong></td> <td>Separate, inconsistent main loops</td> <td>Unified main execution function</td> <td>Standardized testing and execution across all games.</td> </tr> </tbody> </table> <p>The refactoring effort successfully optimized the framework for 32 similar games by focusing on modularity, reusability, and maintainability. Key achievements include:</p> <ul> <li>A <strong>reusable core library</strong> that supports future game development.</li> <li>Simplified and extensible game-specific implementations.</li> <li>Improved performance and developer experience. This approach significantly reduces technical debt, making the codebase more adaptable for evolving project needs. The same framework can now efficiently support additional games with minimal effort, ensuring scalability and consistency across the board. — <h2 id="intro-to-main-code">Intro to main code</h2> <h3 id="1library-gamebasicpy">1.library-GameBasic.py</h3> <p>This code is a general-purpose text-based game engine framework designed to provide a foundation for creating text adventure games. Using abstract classes and object-oriented programming, the framework modularly implements game objects’ fundamental behaviors and logic (e.g., items, containers, devices). Developers can extend the framework to build specific game scenarios and logic. Modules and Functionalities</p> <h4 id="1-gameobject-base-game-object">1. GameObject (Base Game Object)</h4> </li> <li> <strong>Description</strong>: GameObject is the abstract base class for all game objects, defining fundamental attributes and operational logic such as container relationships, movability, and recursive object management.</li> <li> <strong>Key Features:</strong> Dynamic property management, e.g., isMoveable (movable), temperature (temperature), etc. Container relationship management, supporting object addition, removal, and recursive traversal. Provides a mapping between object names and references, facilitating player interactions. <h4 id="2-container-container">2. Container (Container)</h4> </li> <li> <strong>Description:</strong> Inherits from GameObject and represents objects that can contain other items (e.g., drawers, boxes, tables).</li> <li> <strong>Key Features:</strong> Supports container opening and closing operations. Implements logic for storing and retrieving items, including validating the target container’s availability and state. <h4 id="3-device-device">3. Device (Device)</h4> </li> <li> <strong>Description:</strong> Inherits from GameObject and represents devices that can be activated or deactivated (e.g., lights, fans).</li> <li> <strong>Key Features:</strong> Provides operations for turning devices on (turnOn) and off (turnOff). Supports an interface for interacting with other objects. <h4 id="4-substance-substance">4. Substance (Substance)</h4> </li> <li> <strong>Description:</strong> Defines substances with physical properties (e.g., melting point, boiling point) and dynamically adjusts their states (solid, liquid, or gas) based on temperature.</li> <li> <strong>Key Features:</strong> Automatically switches the substance’s physical state based on its temperature. Provides descriptive information about the current state. <h4 id="5-world-world">5. World (World)</h4> </li> <li> <strong>Description:</strong> Inherits from Container and represents the game scene or environment, serving as the root container for all game objects.</li> <li> <strong>Key Features:</strong> Manages all objects within the scene and their states. Generates natural language descriptions of the current scene. <h4 id="6-agent-agent">6. Agent (Agent)</h4> </li> <li> <strong>Description:</strong> Represents the player’s in-game proxy, responsible for managing the player’s items (e.g., inventory).</li> <li> <strong>Key Features:</strong> Implements logic for managing player items. Provides readable descriptions of player items. <h4 id="7-textgame-text-game-logic">7. TextGame (Text Game Logic)</h4> </li> <li> <strong>Description:</strong> Provides a general game logic framework, including world initialization, action registration, score calculation, and player interaction.</li> <li> <strong>Key Features:</strong> Defines abstract methods like initializeWorld() and getTaskDescription() for specific game logic implementation. Supports parsing and executing player actions, such as picking up and placing items. Manages game states, including game over and victory conditions.</li> </ul> <h3 id="2-test_running-00_test_executorpy">2. Test_running-0.0_Test_executor.py</h3> <p>This code serves as a universal command executor designed to run specified game scripts via the command line and execute corresponding game commands. It loads commands from predefined text files, passes them to the game script, and simulates player input. This simplifies testing processes and is suitable for batch execution and debugging of text-based adventure games.</p> <hr> <h4 id="code-structure-and-functionality">Code Structure and Functionality</h4> <h5 id="1-get_commands-function">1. <code class="language-plaintext highlighter-rouge">get_commands</code> Function</h5> <ul> <li> <strong>Purpose</strong>: <ul> <li>Loads commands from a specified file path.</li> </ul> </li> <li> <strong>Explanation</strong>: <ul> <li>Reads a command file located in the <code class="language-plaintext highlighter-rouge">playthroughs</code> directory (e.g., <code class="language-plaintext highlighter-rouge">bath-tub-water-temperature-playthrough.txt</code>) using the <code class="language-plaintext highlighter-rouge">get_commands</code> function from the <code class="language-plaintext highlighter-rouge">command_runner</code> module and returns a list of commands.</li> </ul> </li> </ul> <h5 id="2-execute_commands-function">2. <code class="language-plaintext highlighter-rouge">execute_commands</code> Function</h5> <ul> <li> <strong>Purpose</strong>: <ul> <li>Combines a list of commands into a single string and executes them using <code class="language-plaintext highlighter-rouge">subprocess</code>.</li> </ul> </li> <li> <strong>Explanation</strong>: <ul> <li>Runs the specified game script (e.g., <code class="language-plaintext highlighter-rouge">bath-tub-water-temperature.py</code>) with the combined commands passed as arguments via <code class="language-plaintext highlighter-rouge">subprocess.run</code>.</li> </ul> </li> </ul> <h5 id="3-command-line-argument-parsing">3. Command-Line Argument Parsing</h5> <ul> <li> <strong>Uses <code class="language-plaintext highlighter-rouge">argparse</code> to parse command-line arguments</strong>: <ul> <li> <code class="language-plaintext highlighter-rouge">game_name</code>: Specifies the name of the game script to be executed (e.g., <code class="language-plaintext highlighter-rouge">bath-tub-water-temperature</code>).</li> <li>Automatically locates the corresponding command file (<code class="language-plaintext highlighter-rouge">../playthroughs/{game_name}-playthrough.txt</code>) and loads the commands.</li> </ul> </li> </ul> <h4 id="execution-flow">Execution Flow</h4> <h5 id="input">Input</h5> <ul> <li>The user specifies the name of the game script via the command line.</li> </ul> <h5 id="processing">Processing</h5> <ol> <li>The code locates the command file corresponding to the specified game.</li> <li>It loads the commands from the file using <code class="language-plaintext highlighter-rouge">get_commands</code>.</li> <li>It invokes <code class="language-plaintext highlighter-rouge">execute_commands</code> to combine and execute the commands via <code class="language-plaintext highlighter-rouge">subprocess</code>.</li> </ol> <h5 id="output">Output</h5> <ul> <li>Displays the executed commands.</li> <li>Runs the specified game script, simulating player interactions.</li> </ul> <h4 id="usage-example">Usage Example</h4> <ul> <li> <strong>Assuming the game script is <code class="language-plaintext highlighter-rouge">bath-tub-water-temperature.py</code> and the corresponding command file is <code class="language-plaintext highlighter-rouge">bath-tub-water-temperature-playthrough.txt</code></strong>: <ul> <li> <strong>Command</strong>: <div class="language-bash highlighter-rouge"> <div class="highlight"><pre class="highlight"><code>python 0.0_Test_executor.py bath-tub-water-temperature
</code></pre></div> </div> </li> <li> <strong>Execution</strong>: <ol> <li>Loads commands from <code class="language-plaintext highlighter-rouge">../playthroughs/bath-tub-water-temperature-playthrough.txt</code>.</li> <li>Executes <code class="language-plaintext highlighter-rouge">bath-tub-water-temperature.py</code> with the loaded commands.</li> </ol> </li> </ul> </li> </ul> <hr> <h4 id="code-logic-summary">Code Logic Summary</h4> <h5 id="1-modular-design-1">1. Modular Design</h5> <ul> <li>The <code class="language-plaintext highlighter-rouge">get_commands</code> function abstracts command-loading logic, enhancing reusability.</li> <li>The <code class="language-plaintext highlighter-rouge">execute_commands</code> function encapsulates execution logic, improving code readability and maintainability.</li> </ul> <hr> <h5 id="2-flexibility-and-extensibility">2. Flexibility and Extensibility</h5> <ul> <li>Command-line argument parsing supports testing and running different game scripts.</li> <li>Automatically maps game scripts to their corresponding command files, reducing manual effort.</li> </ul> <hr> <h5 id="3-ease-of-debugging">3. Ease of Debugging</h5> <ul> <li>Prints detailed information about executed commands for easier debugging.</li> <li>Uses <code class="language-plaintext highlighter-rouge">subprocess.run</code> to ensure safe and reliable command execution.</li> </ul> <hr> <h5 id="4-adaptability">4. Adaptability</h5> <ul> <li>Supports cross-platform execution as long as the Python environment and file paths are correctly configured. <h3 id="3test_running-command_runnerpy">3.Test_running-command_runner.py</h3> <p>The main function of this code is to extract valid game commands from a specified <code class="language-plaintext highlighter-rouge">playthrough</code> file and return them as a list. By parsing the file content, it filters out commands that start with <code class="language-plaintext highlighter-rouge">&gt;</code> and prepares them for batch testing or game debugging.</p> </li> </ul> <hr> <h4 id="code-structure-and-functionality-1">Code Structure and Functionality</h4> <ol> <li> <strong><code class="language-plaintext highlighter-rouge">get_commands</code> Function</strong> <ul> <li> <strong>Purpose</strong>:<br> Load commands from a specified file path and filter valid command lines.</li> <li> <strong>Logic</strong>: <ul> <li>Opens the file at the specified path and reads it line by line.</li> <li>Extracts lines starting with <code class="language-plaintext highlighter-rouge">&gt;</code>, removing the <code class="language-plaintext highlighter-rouge">&gt;</code> symbol and surrounding whitespace.</li> <li>Stores the filtered commands in a list and returns them.</li> </ul> </li> </ul> <p><strong>Example Input File</strong>:</p> <div class="language-text highlighter-rouge"> <div class="highlight"><pre class="highlight"><code>&gt; take apple
&gt; put apple in basket
look around
</code></pre></div> </div> <p><strong>Output</strong>:</p> <div class="language-python highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="sh">"</span><span class="s">take apple</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">put apple in basket</span><span class="sh">"</span><span class="p">]</span>
</code></pre></div> </div> </li> <li> <strong>Command-Line Execution</strong> <ul> <li> <strong>Purpose</strong>:<br> Allows specifying the file path from the command line to load commands.</li> <li> <strong>Logic</strong>: <ul> <li>Uses <code class="language-plaintext highlighter-rouge">argparse</code> to accept the <code class="language-plaintext highlighter-rouge">file_path</code> parameter from the command line.</li> <li>Calls the <code class="language-plaintext highlighter-rouge">get_commands</code> function to read commands from the specified file path.</li> <li>Prints the loaded commands (for debugging purposes).</li> </ul> </li> </ul> </li> <li> <strong>Usage</strong><br> Run the following command to load a command file: <div class="language-bash highlighter-rouge"> <div class="highlight"><pre class="highlight"><code>python command_runner.py ../playthroughs/bath-tub-water-temperature-playthrough.txt
</code></pre></div> </div> <p><strong>Example Output</strong>:</p> <div class="language-plaintext highlighter-rouge"> <div class="highlight"><pre class="highlight"><code>Loaded commands: ['take apple', 'put apple in basket']
</code></pre></div> </div> </li> </ol> <hr> <h4 id="code-logic-summary-1">Code Logic Summary</h4> <ol> <li> <strong>Simplicity and Efficiency</strong> <ul> <li>Encapsulates the command extraction logic into a single function for reusability.</li> <li>Filters valid commands to ensure correct input format.</li> </ul> </li> <li> <strong>High Extensibility</strong> <ul> <li>Can be used for different game test scripts by specifying various command file paths.</li> <li>The <code class="language-plaintext highlighter-rouge">get_commands</code> function can be integrated into more complex execution frameworks.</li> </ul> </li> <li> <strong>Debugging-Friendly</strong> <ul> <li>Prints the loaded commands to verify the correctness of the command extraction process.</li> </ul> </li> </ol> <p>This utility provides a reliable and reusable method for extracting game commands, simplifying the workflow for text-based game testing and debugging.</p> <h2 id="how-to-run-this-code">How to run this code?</h2> <h2 id="demo-video">Demo Video</h2> <p><a href="https://youtu.be/MHR61h1qEzs" rel="external nofollow noopener" target="_blank"><img src="https://img.youtu.be/MHR61h1qEzs/0.jpg" alt="How to run this code?"></a></p> <h2 id="instructions-for-running-the-test"><strong>Instructions for Running the Test</strong></h2> <p>Below are detailed instructions on how to use <code class="language-plaintext highlighter-rouge">Test_running-0.0_Test_executor.py</code> to run tests and switch between different games.</p> <hr> <h3 id="step-1-open-the-test-file"><strong>Step 1: Open the Test File</strong></h3> <ol> <li>Locate the <code class="language-plaintext highlighter-rouge">Test_running-0.0_Test_executor.py</code> file in your project directory.</li> <li>Confirm that the file exists and is accessible, or right-click the file to find its relative path.</li> </ol> <hr> <h3 id="step-2-navigate-to-the-file-directory"><strong>Step 2: Navigate to the File Directory</strong></h3> <ol> <li>Open a terminal.</li> <li>Enter the following command to navigate to the directory containing the test file: <div class="language-bash highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="nb">cd</span> &lt;test_running_file_relative_path&gt;
</code></pre></div> </div> <p>Replace <code class="language-plaintext highlighter-rouge">&lt;test_running_file_relative_path&gt;</code> with the relative path of <code class="language-plaintext highlighter-rouge">Test_running-0.0_Test_executor.py</code>.</p> </li> </ol> <hr> <h3 id="step-3-run-the-test-file"><strong>Step 3: Run the Test File</strong></h3> <ol> <li>To execute the test file and launch a specific game, use the following command: <div class="language-bash highlighter-rouge"> <div class="highlight"><pre class="highlight"><code>python 0.0_Test_executor.py balance-scale-heaviest
</code></pre></div> </div> <ul> <li> <code class="language-plaintext highlighter-rouge">balance-scale-heaviest</code> is the name of the game. You can replace it with the name of another game to run a different one.</li> <li>Example game names can be found in the <code class="language-plaintext highlighter-rouge">../playthroughs</code> folder, such as: <ul> <li><code class="language-plaintext highlighter-rouge">bath-tub-water-temperature</code></li> <li><code class="language-plaintext highlighter-rouge">cube-weight-guess</code></li> </ul> </li> </ul> </li> <li>Press <strong>Enter</strong>, and the game will start. The program will load the corresponding command file and execute the game logic.</li> </ol> <hr> <h3 id="step-4-switch-between-games"><strong>Step 4: Switch Between Games</strong></h3> <ol> <li>To run another game, repeat Step 3 and replace the game name with a new one. For example: <div class="language-bash highlighter-rouge"> <div class="highlight"><pre class="highlight"><code>python 0.0_Test_executor.py bath-tub-water-temperature
</code></pre></div> </div> </li> <li>Each time you run a new game, the program will load the respective commands and simulate the game process.</li> </ol> <hr> <h3 id="usage-example-1"><strong>Usage Example</strong></h3> <p>Here is an example of running multiple games:</p> <ol> <li>Navigate to the test file directory: <div class="language-bash highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="nb">cd</span> /path/to/test/running/directory
</code></pre></div> </div> </li> <li>Run the first game (e.g., <code class="language-plaintext highlighter-rouge">balance-scale-heaviest</code>): <div class="language-bash highlighter-rouge"> <div class="highlight"><pre class="highlight"><code>python 0.0_Test_executor.py balance-scale-heaviest
</code></pre></div> </div> </li> <li>Switch and run the next game (e.g., <code class="language-plaintext highlighter-rouge">bath-tub-water-temperature</code>): <div class="language-bash highlighter-rouge"> <div class="highlight"><pre class="highlight"><code>python 0.0_Test_executor.py bath-tub-water-temperature
</code></pre></div> </div> </li> </ol> <hr> <h3 id="important-notes"><strong>Important Notes</strong></h3> <ol> <li>Ensure Python is installed on your system and the <code class="language-plaintext highlighter-rouge">python</code> command works in your terminal.</li> <li>Verify that the <code class="language-plaintext highlighter-rouge">Test_running-0.0_Test_executor.py</code> file path is correct and that all dependent command files exist in the <code class="language-plaintext highlighter-rouge">../playthroughs</code> directory.</li> <li>To avoid path errors, consider right-clicking and copying the relative path to the file.</li> <li>The game name must match the command file name in the <code class="language-plaintext highlighter-rouge">playthroughs</code> folder; otherwise, the program will fail to load the game.</li> </ol> <hr> <p>By following these steps, you can efficiently run specific games and switch between different test games to validate the logic or enjoy the game content!</p> </body></html>